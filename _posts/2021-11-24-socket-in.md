---
layout: post
author: Ghosts
title: Socket 통신 개념잡기
excerpt: "양반향 통신의 Socket에 대해서 알아보겠다."
date: 2021-12-09T11:28:03.104Z
category:
- study
summary: socket 
keywords: blog
thumbnail: "/assets/img/posts/socket.png"
usemathjax: false
---

## 소켓(Socket) 프로그래밍 이란?

>Server와 Client가 특정 Port를 통해 실시간으로 양방향 통신을 하는 방식

Socket 연결은 `TCP/IP 프로토콜`을 기반으로 맺어진 네트워크 연결 방식입니다. 그리고 이러한 Socket 연결 방식으로 프로그래밍 하는 것을 소켓(Socket) 프로그래밍이라고 하는데, Socket 프로그래밍은 Server와 Client가 특정 Port를 통해 `연결을 유지`하고 있어 실시간으로 `양방향` 통신을 할 수 있는 방식입니다. Client만 필요한 경우에 요청을 보낼 수 있는 Http 프로그래밍과 달리 Socket 프로그래밍은 Server 역시 Client로 요청을 보낼 수 있으며, 계속 연결을 유지하는 연결지향형 방식이기 때문에 실시간 통신이 필요한 경우에 자주 사용됩니다.

### 소켓(Socket) 프로그래밍 특징

Server와 Client가 계속 연결을 유지하는 `양방향` 프로그래밍 방식이다.
Server와 Client가 `실시간`으로 데이터를 주고받는 상황이 필요한 경우에 사용된다.
실시간 동영상 Streaming이나 온라인 게임 등과 같은 경우에 자주 사용된다.

### java 에서 사용되는 소켓 통신 예제

```java
public class App 
{	
	public static ClassPathXmlApplicationContext context;
	
	private static final Logger log = LoggerFactory.getLogger(App.class);
	
    public static void main( String[] args )
    {	
    	context = new org.springframework.context.support.ClassPathXmlApplicationContext("config/app.xml");
    	
    	boolean isDev = System.getProperty("spring.profiles.active") == null||"local".equals(System.getProperty("spring.profiles.active"))||"dev".equals(System.getProperty("spring.profiles.active"));
    	
    	if(isDev == true) {    		
    		log.debug("IS DEV START ------------------------------------------------------------------------------");
        	//TestRealTimeServer server = context.getBean(TestRealTimeServer.class);
        	RealTimeServer server = context.getBean(RealTimeServer.class);
    		server.run();
    	}
    	
    }
}
```
먼저 제일 처음 App 앱에서 RealTimeServer 객체를 생성 하여 구동될경우 Server 인스턴스가 생성 될수 있는 Property 설정값을을 재정의 한다. 

```java 
package com.realtime.server;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.net.ServerSocket;
import java.net.Socket;
import java.net.URLDecoder;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Properties;
import java.util.UUID;
import java.util.concurrent.ArrayBlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.RejectedExecutionException;
import java.util.concurrent.ThreadPoolExecutor;
import java.util.concurrent.TimeUnit;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.support.ReloadableResourceBundleMessageSource;
import org.springframework.stereotype.Component;

import com.realtime.Constants;
import com.realtime.util.FileLogUtil;
import com.realtime.util.StringUtil;


@Component
public class RealTimeServer {

	private static final Logger log = LoggerFactory.getLogger(RealTimeServer.class);
	
	@Value("#{realtimeProp['server.port']}")
	private int _port;
	
	@Value("#{realtimeProp['profile.name']}")
	private String _profile;
	
	@Value("#{realtimeProp['command.file']}")
	private String _basename;	
	
	private ReloadableResourceBundleMessageSource messageSource;			// 2018.12
	
	private static ExecutorService pool = new ThreadPoolExecutor( 10, 10, 0L, TimeUnit.MILLISECONDS, new ArrayBlockingQueue<Runnable>(100, true ) );		// 스레드 풀 추가. 2018.12
	public static volatile List<String> mbrNoList = new ArrayList<>();					// 처리중 mbrNo 목록
	public static volatile Map<String, Runnable> collisionMap = new Hashtable<>();		// mbrNo 충돌로 대기중인 task 맵
	
	private final static String _LAST_MODIFY_DATE = "2018-08-30 13:36";	
	public static Date LASTEXEC_DATETIME = null;	
	
	private final static int _BODY_LENGTH  	    =  400;  // 데이터바디부
	private final static int _DATA_LENGTH  		= 1284;  // 데이터부의 총 길이
	
	public static int THREAD_COUNT = 0;
	public static final int MAX_THREAD_COUNT = 10;
	private static Object cntObj = new Object();
	
	private String state = "run";
	
	private ServerSocket serverSocket = null;
	private InputStream in = null;
	private BufferedReader br = null;
	private Socket socket = null;
	private StringBuffer sbRead = null;
	
	public void run() {
		
    	// shutdown command 모니터
		CommandMonitor monitor = new CommandMonitor();
		monitor.start();
    	
		// mbrNo 충돌 처리 스레드
		Runnable retryer = new Retryer();
		Thread t = new Thread(retryer);
		t.start();


    	try { 
			serverSocket = new ServerSocket(_port); 

			// 서버 시작 알림
			log.debug(String.format("%s RealTimeServer Started : port = %s / %s", _profile, _port, _LAST_MODIFY_DATE));
    		
    		while(true) {
    		
    			// 연결대기
    			socket = serverSocket.accept();
	    			
	    		// 접속 연결 시간 저장
	    		LASTEXEC_DATETIME = new Date();
        		
        		log.debug("");
	    		log.debug("=========================================================");
	    		log.debug("Socket connection has established...... ");
	    		log.debug("=========================================================");
	    		log.debug("");


	    		in = socket.getInputStream();
	        	br = new BufferedReader(new InputStreamReader(in, Constants.ENCODE_TYPE));

	        	sbRead = new StringBuffer();

	        	String telegram = null;

	        	while(true) {

	        		try {
	        			int c;    			

	        			if((c = br.read())!=-1) {

	        				sbRead.append((char) c);

	        				byte[] b = (sbRead.toString()).getBytes(Constants.ENCODE_TYPE);    		    					

	        				if(_DATA_LENGTH == b.length) {

	        					telegram = new String(b, Constants.ENCODE_TYPE);            	    					

	        					// 데이터부만 남기고 삭제
	        					telegram = telegram.substring(_DATA_LENGTH-_BODY_LENGTH);

	        					// 데이터을 파일 형태로 저장
	        					FileLogUtil.write(telegram);

	        					// 데이터처리	    		
	        					setTelegram(telegram);

	        					sbRead.setLength(0); // 버퍼초기화							

	        					telegram = null;
	        				}
	        			} else {					// client 가 정상적으로 연결 종료 한 경우
	        				log.info("Client has gone.");
	        				break;		  
	        			}
	        		}
	        		catch (IOException ex) {		// client 와 연결이 예상치 않게 끊어 지는 경우...
	    				log.debug(ex.getMessage());
	    				break;
	    			} catch(Exception ex) {
	    				log.debug("ERROR has occured"+ex.getMessage());
	    				break;
	    			}
	        	}
	        	
	        	if (br!=null) {
					br.close();
					log.info("The BufferedReader has closed");
				}
				if (in!=null) {
					in.close();
					log.info("The InputStream has closed");
				}
				if (socket!=null) {
					socket.close();
					log.info("The Socket has closed");
				}

				if ( state.equals("stop") ) {		// 소켓 스트림 read 루프 종료 했는데 커맨드 stop 이면 메인 스레드 종료.
					break;
				}
    		}
		} catch (IOException e) {
			log.info("An Unused ServerSocket has closed.");
			log.error("Server Error >> "+e.getMessage());
		} catch (Exception e) {
    		e.printStackTrace();
    		log.debug("RealTimeServer.run() Exception >>>>>>>>>>>>>>>>>>>>>>>> "+e.getMessage());
		} finally {
			if (br != null)
				try {
					br.close();
				} catch (Exception e) {
					e.printStackTrace();
		    		log.error("RealTimeServer.run() Exception >>>>>>>>>>>>>>>>>>>>>>>> "+e.getMessage());
				}
		}

		log.info("");
		log.info("Realtime sales data receiving thread has terminated. ");
		//System.exit(0);
	}



	/**
	 * 자원 회수
	 */
	private void releaseSocketResources() {
		try {
			if (socket!=null && !socket.isClosed()) {
				socket.shutdownInput();
				socket.close();
				//log.info("소켓 해제 완료.");
			}
			
			if (serverSocket!=null ) {						// 서버 소켓 해제
				serverSocket.close();
				//log.info("서버소켓 해제 완료");
			}		

		} catch (IOException ex) {
			log.error("자원 회수 중 에러 발생 : {}",ex.getMessage());
		}
	}
	
	private void setTelegram(String telegram) throws Exception {
		
		byte[] bytes = telegram.getBytes(Constants.ENCODE_TYPE);
		
		String mbrNo = StringUtil.trimWhitespace(bytes, 3, 100);
		log.debug(String.format("THREAD_COUNT ---------------------------------------------------- %d", THREAD_COUNT));
		
		Runnable task = new SocketThread(telegram);
		
		do {
			String result = RealTimeServer.checkAndSubmitThread ( mbrNo, task );
			
			if (result.equals("COLLISION")) {			// mbrNo 충돌이면 collisionMap 에 보관하여 다음에 다시 처리 시도.
				synchronized(collisionMap) {
					collisionMap.put(attachUniqueKey(mbrNo), task);
				}
				log.info("###### mbrNo collision occured. This job will be kept in the collisionMap. map size : {}, mbrNo is {}", collisionMap.size(), mbrNo);
				break;
			} else if (result.equals("SUCCESS")) {		// 제대로 풀링 됐으면 종료
				break;
			} else { 									// 스레드 풀의 큐가 가득찬 경우 여기서 스레드 큐 빠질때 까지 재시도 2초 대기  (소켓 버퍼에는 쌓이겠지.. )
				log.info("######## The thread pool is full and waiting to be emptied. mbrNo : {}",mbrNo);
				Thread.sleep(2000);
			}
		} while(true);

	}




	/*******************************************************************
	/******************************************************************* 
	/*******************************************************************/
	
	public static void addToThreadCount() {
		synchronized (cntObj) {
			RealTimeServer.THREAD_COUNT++;
		}
	
	}
	
	public static void subtractFromThreadCount() {
		synchronized (cntObj) {
			if(RealTimeServer.THREAD_COUNT > 0) {
				RealTimeServer.THREAD_COUNT--;
			}
			
			if(RealTimeServer.THREAD_COUNT < 0) {
				RealTimeServer.THREAD_COUNT = 0;
			}			
		}
	}


	/**
	 * 입력받은 값을 유니크 하게 뒤에 년월일+난수를 덧붙인다.
	 * @param src
	 * @return
	 */
	private String attachUniqueKey(String src) {
		if (src == null )  {
			return null;
		}
		String random = String.format("__%s%s" , new SimpleDateFormat("yyyyMMddhhmmss").format(new Date()), UUID.randomUUID().toString().toUpperCase().replace("-", "").substring(0,9));
		return src + random;
	}
	
	private String removeUniqueKey(String obj) {
		return obj.substring(0,obj.length()-25);
	}


	/**
	 * 스레드 풀의 큐 갯수 구하기.
	 * @return
	 */
	public static int getThreadPoolQueueSize() {
		int size = ((ThreadPoolExecutor)pool).getQueue().size();
		return size;
	}


	/**
	 * mbrNoList 에서 mbrNo 제거. 
	 * @param mbrNo
	 */
	public static void removembrNo(String mbrNo) {
		synchronized(mbrNoList) {
			mbrNoList.remove(mbrNo);
			log.info("###### mbrNo removed from the currently running mbrNo List. mbrNo List size : {}, mbrNo : [{}]", mbrNoList.size(), mbrNo);
		}
	}


	/**
	 * mbrNoList 에  실행하려는 task 의 mbrNo가 이미 있는지 확인하고 없으면 task 를 스레드 풀에.... 동기화 되어야 함.
	 * 
	 * @param mbrNo
	 * @param task
	 * @return 스레드 풀링 성공 여부. <br>SUCCESS: 스레드 풀링 성공 <br>COLLISION: 기존에 동일 mbrNo 매출건 처리중이라 대기 해야함 <br>FULL:스레드 풀의 큐가 가득참. 
	 */
	private static String checkAndSubmitThread(String mbrNo, Runnable task) {
		synchronized(mbrNoList) {
			if (mbrNoList.contains(mbrNo) == false ) {			// 기존에 동일 mbrNo 매출건이 처리 중이 아니면.
				try {
					pool.submit(task);						// 스레드 풀에 제출
					mbrNoList.add(mbrNo);								// 실행하려는 taks의 mbrNo를  mbrNoList에 add
					log.info("###### A new mbrNo is added to the thread pool. mbrNoList size : {}, mbrNo : [{}]", mbrNoList.size(), mbrNo);
					
					/*
				 	// 테스트
					for ( String cur_mbrNo : mbrNoList) {
						log.info("________ Currently Running mbrNo : [{}]", cur_mbrNo);
					}*/
					
				} catch ( RejectedExecutionException ex) {
					return "FULL";
				}
				return "SUCCESS";
			} else {
				return "COLLISION";
			}
		}
	}	


	/**
	 * safe shutdown 용 프로퍼티 파일 경로 리턴
	 * @param basename
	 * @return safe shutdown 용 프로퍼티 파일 경로
	 */
	public String getCommandPath(String basename) {
		
		String parentPath = null;
		
		if( _profile.equalsIgnoreCase("local") == false ) {
			File jarPath = new File(RealTimeServer.class.getProtectionDomain().getCodeSource().getLocation().getPath());
			parentPath = jarPath.getParentFile().getAbsolutePath();		// jar 파일로 실행되는 경우에는 jar 파일명 자체를 빼야 하기 때문에 부모 경로를 얻는다.
		} else {
			String jarPath = RealTimeServer.class.getProtectionDomain().getCodeSource().getLocation().getPath();
			parentPath = jarPath;						// 로컬일 때 (이클립스 실행)
		}
		
		String decodedPath = null;
		try {
			decodedPath = URLDecoder.decode(parentPath, "UTF-8");
		} catch (Exception ex ) {
			log.error(ex.getMessage());
		}
		decodedPath = decodedPath + basename;
		
		log.info("command properties : {}",  decodedPath+".properties");
		
		return decodedPath;
	}


	/**
	 * 스레드 풀 종료
	 */
	private void shutdownTreadPool() {
		pool.shutdown();
	}


	/**
	 * 서버 스레드 종료
	 */
	private void closeServerSocket() {
		try {
			if (serverSocket!=null && serverSocket.isClosed()==false) {						// 서버 소켓 해제
				serverSocket.close();
				log.info("The ServerSocket has closed");
			}		
		} catch (IOException ex) {
			log.error("서버 소켓 종료 중 에러 발생 : {} ", ex.getMessage() );
		}
	}




	/*******************************************************************
	/*******************************************************************
	/*******************************************************************
	
	
	/**
	 * safe shutdown 모니터 스래드
	 */
	public class CommandMonitor extends Thread {
		private final int interval = 1000;
		private String commandPath = null;
		private int shutdownStep = 0;			// 0 : 종료전, 1 : 종료시작 소켓 연결 해제, collisionMap 비워지길 기다림,  2: 스레드풀 셧 다운 시작 , 3: 완료. 

		@Override
		public void run() {

			commandPath = getCommandPath(_basename);
			
			messageSource =  new ReloadableResourceBundleMessageSource();
			messageSource.setBasename("file:"+commandPath);
			messageSource.setCacheSeconds(3);
			messageSource.setDefaultEncoding("UTF-8");
	    	
	    	
			Properties prop = new Properties();
			prop.setProperty("command", "run");		// 시작 시 run 으로 변경.
			
			try {
				log.info("resetting command properties : {} ", commandPath+".properties");
				prop.store(new FileOutputStream(commandPath+".properties"), "");
			} catch (Exception ex ) {
				log.error(ex.getMessage());
			}
	    	
			while(true) {
				try {
					state = messageSource.getMessage("command", null, Locale.US);
					//log.info("command : {} ",state);
					if (state.equals("stop")) {

						/*if ( isConnected ) {
							log.info("br.ready() :::: {} ",br.ready());
						}*/	
								
						if ( shutdownStep == 0 && ( sbRead.length() == 0)  ) {		// 소켓에서 읽을 데이터 없으면 
							shutdownStep = 1;
							log.info("");
							log.info("Shutdown step 1 >>>> Starting to close socket.. ");
							log.info("");
							releaseSocketResources();
						} else if ( shutdownStep == 1 && collisionMap.size() == 0 ) {			// 스텝 1인 상태에서 출동한 mbrNo보관용 맵이 빈 경우
							shutdownStep = 2;
							log.info("");
							log.info("Shutdown step 2 >>>> Starting to shutdown Thread Pool.. Please wait until all tasks have completed..");
							log.info("");
							shutdownTreadPool();
						} else if ( shutdownStep == 2 ) {
							shutdownStep = 3;
							log.info("");
							log.info("Shutdown step 3 >>>> Realtime sales data receiving server will be shutdown soon.");
							log.info("");
							//System.exit(0);				// 작업 스레드 종료 후 시스템 종료.
						} else if (shutdownStep == 3 ) {
							log.info("****************************************************************");
							log.info("****** Realtime sales data receiving server has shutdown. ******");
							log.info("****************************************************************");
							break;
						}
					}
					Thread.sleep(interval);
					
					/*log.debug("");
					log.debug(String.format("THREAD_COUNT ---------------------------------------------------- %d", THREAD_COUNT));
					log.debug(String.format("Thread Pool Queue size ------------------------------------------ %d", getThreadPoolQueueSize()));
					log.debug(String.format("Collision Map size --------------------------------------------------- %d", collisionMap.size()));*/
					
				} catch(InterruptedException ex) {
					log.error("Thread.sleep 에러 : {}",ex.getMessage());
				} /*catch (IOException e) {
					log.error("BufferedReader.ready 호출 중 에러 발생 : {} ",e.getMessage() );
				}*/
			}
			

		}
	}
	
	
	
	
	
	/**
	 * mbrNo 충돌난 매출건 재시도 스레드 
	 * 
	 * @author 
	 *
	 */
	public class Retryer implements Runnable {
		private final int interval = 2000;
		
		@Override
		public void run() {
			
			while(true) {

				synchronized(collisionMap) {
					if (state.equals("stop") && collisionMap.size() == 0 ) {		// shutdown 명령 & 실행 대기중 job 없으면 재시도 스레드 종료
						break;
					}
				
					if (collisionMap.size() > 0 ) {
	
						log.info("####### Start retry thread.... collisionMap size : {}", collisionMap.size());
						
						for(Iterator<Map.Entry<String, Runnable>> it = collisionMap.entrySet().iterator(); it.hasNext(); ) {
		
							Map.Entry<String, Runnable> entry = it.next();
							String mbrNo = removeUniqueKey(entry.getKey());
							log.info("####### Check if any Thread with the Same mbrNo is running.. mbrNo : [{}]", mbrNo);
							
							String result = RealTimeServer.checkAndSubmitThread( mbrNo, entry.getValue() );
							
							if (result.equals("SUCCESS")) {				// 풀링 성공이면 collisionMap 에서 스레드 제거..  아직 mbrNo 충돌이거나, 스레드 풀 큐가 가득 찼으면 대기. 
								it.remove();
								log.info("###### Finally, Long-awaited task has launched. remaining map size : {},  mbrNo : [{}]", collisionMap.size(), removeUniqueKey(entry.getKey()));
							}
						}
					}
				}
				
		        try {
		        	Thread.sleep(interval);
		        }	
		        catch(InterruptedException ex) {
					log.error("Thread.sleep 에러 : {}",ex.getMessage());
				}	        	
			}
		}
	}

}


```

Socket 접속에 필요한 구조가 생성 되었다. 
~~~java
/* Socket Thread*/
package com.realtime.server;

import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.realtime.enums.AUTO_APPL_HDL_CD;
import com.realtime.message.KakaoDeductCancleMessage;
import com.realtime.message.KakaoDeductMessage;
import com.realtime.message.KakaoMessage;
import com.realtime.message.SMSSender;
import com.realtime.model.HS10Model;
import com.realtime.model.ResultModel;


public class SocketThread extends Thread {

	private static final Logger log = LoggerFactory.getLogger(SocketThread.class);
	
	private String _telegram = null;
	
	private static final String adminSMSNumber = "01099117307";
	
	public SocketThread() {}
	public SocketThread(String telegram) {
		_telegram = telegram;
	}
	
	
	public void run() {
		
		// 전문처리 실행
		//RealTimeServer.THREAD_COUNT++;
		RealTimeServer.addToThreadCount();
			
		// 전문으로 모델을 정의 한다.
		// 전문저장하고, 회원정보도 여기서 저장한다.
		HS10Model model = null;		
		ResultModel result = new ResultModel();
		
		try {			
			
			model = new HS10Model(_telegram);
			
			// 이제 저장된 전문으로 비용처리 시작
			result = model.process();
			
			if(result.isSuccess() == true) {
				// 비용처리/취소 성공
				// 카카오알림톡 전송
				
				if(result.getCode() == AUTO_APPL_HDL_CD.S03 || result.getCode() == AUTO_APPL_HDL_CD.S04) {					
					
					try {
						
						
						// 원 대상 번호						
						log.debug("원 수신자 : >> "+result.getHs10Model().getMemberInfo().getHpNo());
								
						String telNo = result.getHs10Model().getMemberInfo().getHpNo();
						
						result.getHs10Model().getMemberInfo().setHpNo(telNo);
						
						boolean isDev = System.getProperty("spring.profiles.active") == null||"local".equals(System.getProperty("spring.profiles.active"))||"dev".equals(System.getProperty("spring.profiles.active"));
						
						if(isDev) {
							// 개발모드 이면 관리자 전화번호로 셋팅
							result.getHs10Model().getMemberInfo().setHpNo(adminSMSNumber);
						}
						
						
						KakaoMessage kakao = null;
						
						if(result.getCode() == AUTO_APPL_HDL_CD.S03) {
							kakao = new KakaoDeductMessage(result.getHs10Model());
						}
						else if(result.getCode() == AUTO_APPL_HDL_CD.S04) {
							kakao = new KakaoDeductCancleMessage(result.getHs10Model());
						}	
						
						kakao.send();
					}
					catch(Exception ex) {
						// 성공인데 차감/취소 말고 다른게 있다면 알리기
						SMSSender sms = new SMSSender();
						
						// 이도한도 받기					
						sms.setTo(adminSMSNumber);
						sms.setMessage("HASK Real Time KakaoError >> "+ex.getMessage());
						
						sms.send();
					}					
					
				}
				else {
					// 성공인데 차감/취소 말고 다른게 있다면 알리기
					SMSSender sms = new SMSSender();
					
					// 이도한도 받기					
					sms.setTo(adminSMSNumber);
					sms.setMessage("HASK Real Time Unknown >> "+result.getCode());
					
					sms.send();
				}
			}
			else {
				// 실패
				// 실패사유가 오류라면 관리자에게 SMS 발송
				if(result.getCode() == AUTO_APPL_HDL_CD.P03) {
					// 관리자 SMS 발송
					SMSSender sms = new SMSSender();
					
					// 이도한도 받기					
					sms.setTo(adminSMSNumber);
					sms.setMessage("HASK Real Time Error >> "+result.getMessage());
					
					sms.send();
				}
			}
			
		}
		catch (Exception e) {			
			
			result.setCode(AUTO_APPL_HDL_CD.XX);
			result.setMessage("Exception >> "+e.toString());
		}
		
		RealTimeServer.LASTEXEC_DATETIME = new Date(); // 실행된 마지막 시간을 기록
		
		RealTimeServer.subtractFromThreadCount();
		
		RealTimeServer.removeCi(model.getCi());			// ciList에서 작업 완료된 ci  삭제.

		//log.debug("("+RealTimeServer.THREAD_COUNT+") "+result.getMessage());
		log.debug("("+RealTimeServer.THREAD_COUNT+":"+RealTimeServer.getThreadPoolQueueSize()+") "+result.getMessage());
	}
	
}

~~~

~~~xml
/* app.xml*/
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context"
	xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:util="http://www.springframework.org/schema/util"
	xsi:schemaLocation="
        http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop 
        http://www.springframework.org/schema/aop/spring-aop.xsd
        http://www.springframework.org/schema/tx 
        http://www.springframework.org/schema/tx/spring-tx.xsd
        http://www.springframework.org/schema/util
        http://www.springframework.org/schema/util/spring-util.xsd">
        
        <!-- 트랜잭션 매니저 어노테이션 활성화 -->
        <tx:annotation-driven transaction-manager="transactionManager" />
	
    	<!-- spring 컴포넌트 스캔 범위 지정 -->
        <context:component-scan base-package="com.realtime" />
        
        <import resource="datasource.xml" />
    
</beans>

/* datasouce.xml*/

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:util="http://www.springframework.org/schema/util"
	xmlns:context="http://www.springframework.org/schema/context" xmlns:p="http://www.springframework.org/schema/p" xmlns:tx="http://www.springframework.org/schema/tx"
	xmlns:mybatis="http://mybatis.org/schema/mybatis-spring"
	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd
        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd
        http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd">

	<util:properties id="realtimeProp" location="classpath:config/${spring.profiles.active:local}.xml" />
	
	<bean id="dataSource" class="org.springframework.jdbc.datasource.SimpleDriverDataSource">
        <property name="driverClass" value="#{realtimeProp['oracle.driver']}" />
        <property name="url" value="#{realtimeProp['oracle.url']}" />
        <property name="username" value="#{realtimeProp['oracle.username']}" />
        <property name="password" value="#{realtimeProp['oracle.password']}" />
    </bean>

    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">
        <property name="dataSource" ref="dataSource"></property>
    </bean>

    <bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">
        <property name="dataSource" ref="dataSource" />
        <property name="configLocation" value="classpath:config/mybatis.xml" />
        <property name="mapperLocations">
            <array>
                <value>classpath*:/sql/**/*.xml</value>
            </array>
        </property>
    </bean>

    <bean id="sqlSession" class="org.mybatis.spring.SqlSessionTemplate">
        <constructor-arg ref="sqlSessionFactory"></constructor-arg>
    </bean>
    <bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">
        <property name="basePackage" value="com.realtime.dao" />
        <property name="sqlSessionTemplateBeanName" value="sqlSession" />
    </bean>
	
</beans>
/*local.xml*/
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE properties SYSTEM "http://java.sun.com/dtd/properties.dtd">
<properties>

	<entry key="profile.name">LOCAL</entry>
	
	<entry key="oracle.driver">net.sf.log4jdbc.DriverSpy</entry>
	<entry key="oracle.url">jdbc:log4jdbc:oracle:thin:@localhost</entry>
	<entry key="oracle.username">username</entry>
	<entry key="oracle.password">password</entry>
	
	<entry key="server.port">XXXX</entry>
	
	<entry key="telegram.filePath">C:\_workspace\_log</entry>
	
	<entry key="sms.send.test">true</entry>
	
	<entry key="test.telegram"></entry>

	<entry key="command.file">/command/command-local</entry>
		
</properties>

/* mybatis.xml */
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
    <settings>
        <setting name="jdbcTypeForNull" value="NULL" />
        <setting name="defaultExecutorType" value="REUSE"/> <!-- SIMPLE|REUSE|BATCH -->
        <setting name="defaultStatementTimeout" value="360000"/>
        <setting name="mapUnderscoreToCamelCase" value="true"/>
	</settings>
	<typeAliases>
  		<package name="com.realtime.model"/>
	</typeAliases>
</configuration>
~~~

~~~shell
run.sh
#!/bin/bash

export LANG="ko_KR.UTF-8"

JAVA_HOME=/vol3/jdk1.8
SERVER_HOME=/logichome/tbs/logs/server

cd $SERVER_HOME
nohup $JAVA_HOME/bin/java -jar -Dname=Real -Dlog4jdbc.dump.sql.maxlinelength=0 -Dfile.encoding=UTF-8 -Dspring.profiles.active=real -Dapp.log.home=$SERVER_HOME/logs $SERVER_HOME/com.realtime.jar > /dev/null 2>&1 &

// stop.sh
#!/bin/bash

perl -pi -e 's/run/stop/g' ./command/command-real.properties

~~~


~~~java
/* testRealTimeServer.java*/
package com.realtime.server;

import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

@Component
public class TestRealTimeServer {

	private static final Logger log = LoggerFactory.getLogger(RealTimeServer.class);
	
	@Value("#{realtimeProp['server.port']}")
	private int _port;
	
	@Value("#{realtimeProp['profile.name']}")
	private String _profile;
	
	@Value("#{realtimeProp['test.telegram']}")
	private String telegram;
	
	private final static String _LAST_MODIFY_DATE = "2018-07-31 14:19";	
	
	public static Date LASTEXEC_DATETIME = null;
	
	private final static int _BODY_LENGTH  	    =  400;  // 전문바디부
	private final static int _DATA_LENGTH  		= 1284;  // 데이터부의 총 길이
	
	public static int THREAD_COUNT = 0;
	public static final int MAX_THREAD_COUNT = 10;
	
	public void run() { 
    	
    	try {
    		// 서버 시작 알림
    		log.debug(String.format("%s TestRealTimeServer Started : port = %s / %s", _profile, _port, _LAST_MODIFY_DATE));
    		            	    					
			// 전문부만 남기고 삭제
			telegram = telegram.substring(_DATA_LENGTH-_BODY_LENGTH);
			
    		// 전문을 파일 형태로 저장
			//FileLogUtil.write(telegram);
    		
			// 전문처리	    		
			setTelegram(telegram);
    	}
    	catch (Exception e) {
		}
    	
	}

	private void setTelegram(String telegram) throws InterruptedException {
		// 전문을 처리한다.	
		log.debug(String.format("THREAD_COUNT ---------------------------------------------------- %d", THREAD_COUNT));
		
		if(THREAD_COUNT <= MAX_THREAD_COUNT) {
			// 쓰레드의 수가 최대 수보다 작으면 쓰레드 생성
			Thread socketThread = new Thread(new SocketThread(telegram));
			socketThread.start();
		}
		else {
			Thread.sleep(1000);	
			setTelegram(telegram);
		}
	}
}

~~~


~~~java
/*model */
package com.realtime.model;

import java.io.UnsupportedEncodingException;
import java.lang.reflect.Field;
import java.text.DecimalFormat;
import java.util.Date;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.realtime.App;
import com.realtime.Constants;
import com.realtime.annotation.BindValue;
import com.realtime.enums.AUTO_APPL_HDL_CD;
import com.realtime.service.HS10Service;
import com.realtime.util.DateUtil;
import com.realtime.util.StringUtil;

public class TestModel {
	
	private static final Logger log = LoggerFactory.getLogger(TestModel.class);
	
	private TestService service;
	
	public TestModel() {
		
	}
	
	public TestModel(String telegramSource) throws UnsupportedEncodingException, IllegalArgumentException, IllegalAccessException {		
		
		byte[] bytes = telegramSource.getBytes(Constants.ENCODE_TYPE);
		
		Field[] fields = this.getClass().getDeclaredFields();
		
		for(Field field : fields) {
			
			field.setAccessible(true);						
			
			BindValue bindValue = field.getAnnotation(BindValue.class);
			
			if(bindValue != null) {
		
				int startPosition = bindValue.StartPosition();
				int length = bindValue.Length();
				String name = bindValue.Name();
				
				if(length > 0) {							
					if(field.getType().getCanonicalName().equalsIgnoreCase("int")) {
						field.set(this, StringUtil.trimWhitespaceToInt(bytes, startPosition,length));
					}
					else {
						field.set(this, StringUtil.trimWhitespace(bytes, startPosition,length));
					}
				}
				
				String value = field.get(this).toString();
				
				System.out.println(String.format("%s =  %s | %s(%s)", name, value, value.length(), length));
			}
		}
		
		// 서비스 할당
		service = App.context.getBean(TestService.class);
					
		// 분할, 할부가 아닌경우 고객사사업자번호+CI로 사용자 정보를 업데이트 함
		if(EnableDvied() == false && IsallPayType() == true) {
			
			memberInfo = service.getMemberInfo(ci, designCode);
		}
		
		// 수신매출을 저장		
		service.setData(this);
		
	}
	
	private ResultModel result = new ResultModel();

	// 비용처리
	public ResultModel process() {
		
		// 분할인지 검사
		if(this.EnableDvied() == true) {		
			result.setCode(AUTO_APPL_HDL_CD.R10);
			result.setMessage(String.format("[%s불가] %s %s원", AUTO_APPL_HDL_CD.R10.getName() , this.storeName, this.getUseMoneyString()));
			result.setSuccess(false);
		}
		else if (this.IsallPayType() == false) {
			result.setCode(AUTO_APPL_HDL_CD.R20);
			result.setMessage(String.format("[%s불가] %s %s원", AUTO_APPL_HDL_CD.R20.getName() , this.storeName, this.getUseMoneyString()));
			result.setSuccess(false);
		}
		else if(this.memberInfo == null) {
			result.setCode(AUTO_APPL_HDL_CD.R90);
			result.setMessage(String.format("[%s불가] %s", AUTO_APPL_HDL_CD.R90.getName(), this.ci));
			result.setSuccess(false);
		}
		else if(this.memberInfo != null) {
			
			// 가족카드불가인지보고 처리
			if(this.memberInfo.EnableFamilyCard() == false && this.isFamilyUse() == true) {
				// 가족 카드 불가인데 가족카드 매출
				result.setCode(AUTO_APPL_HDL_CD.R30);
				result.setMessage(String.format("[%s불가] %s %s원", AUTO_APPL_HDL_CD.R30.getName() , this.storeName, this.getUseMoneyString()));
				result.setSuccess(false);
			}
			else {
				
				// 비용처리 시작
				// 이 과정을 통해 SP에서 returnCode, returnMessage가 할당 됨
				service.setApplData(this);
				
				AUTO_APPL_HDL_CD hdlCD = AUTO_APPL_HDL_CD.valueOf(returnCode);
				
				result.setCode(hdlCD);
				
				if(hdlCD == AUTO_APPL_HDL_CD.S03 || hdlCD == AUTO_APPL_HDL_CD.S04) {
					
					if("10".equals(this.getStatementTypeCode())) {
						// 정상
						result.setMessage("[포인트차감] "+this.getStoreName()+" "+this.getApplPntString()+"P");						
					}
					else {
						// 취소
						result.setMessage("[포인트차감취소] "+this.getStoreName()+" "+this.getApplPntString()+"P");
					}
					
					result.setSuccess(true); // 자동신청, 취소의 경우 성공
				}
				else {
					
					// 차감이 되지 않았다.
					// 미설정 항목
					if(hdlCD == AUTO_APPL_HDL_CD.XX) {
						result.setMessage(String.format("[대상아님] %s %s원 | %s >> XX",this.getStoreName(), this.getUseMoneyString(), this.memberInfo.getMbrNo()));
					}
					else if(hdlCD == AUTO_APPL_HDL_CD.F01) {
						result.setMessage(String.format("[불가] %s %s원 | %s >> F01", this.getStoreName(), this.getUseMoneyString(), this.memberInfo.getMbrNo()));
					}
					else if(hdlCD == AUTO_APPL_HDL_CD.P02) {
						result.setMessage(String.format("[포인트부족] %s %s원 | %s >> P02 | %s", this.getStoreName(), this.getUseMoneyString(), this.memberInfo.getMbrNo(), returnMessage));
					}
					else if(hdlCD == AUTO_APPL_HDL_CD.F02) {
						result.setMessage(String.format("[기신청] %s %s원 | %s >> %s", this.getStoreName(), this.getUseMoneyString(), this.memberInfo.getMbrNo(), this.realTimePK));
					}
					else if(hdlCD == AUTO_APPL_HDL_CD.P10) {
						result.setMessage(String.format("[신청항목없음] %s %s원 | %s >> %s", this.getStoreName(), this.getUseMoneyString(), this.memberInfo.getMbrNo(), this.realTimePK));
					}					
					else {
						result.setMessage(String.format("[오류] %s %s원 >> %s | %s",this.getStoreName(), this.getUseMoneyString(), returnCode, returnMessage));
					}
					
					result.setSuccess(false);
				}
				
				log.debug(result.getMessage());
			}
		}
		else {
			
			log.error("사용자 정보를 찾을 수 없음 : "+ci);
			
			result.setCode(AUTO_APPL_HDL_CD.R99);
			result.setMessage(String.format("[%s] %s %sP", AUTO_APPL_HDL_CD.R99.getName() , this.storeName, this.getUseMoneyString()));
			result.setSuccess(false);
		}
		
		result.setHs10Model(this);
		
		return result;
	}
	
	private MemberInfoModel memberInfo = null;
	
	private int seq;
	
	public int getSeq() {
		return seq;
	}

	public void setSeq(int seq) {
		this.seq = seq;
	}

	// 전문에서 자동으로 파싱됨
	@BindValue(StartPosition=0, 	Length=1	, Name="매출구분(1:승인/2:취소)")
	private String statementType; 	// 매출구분 > 1:승인, 2:취소
	
	@BindValue(StartPosition=1, 	Length=2	, Name="카드구분(01:신용/11:체크)")
	private String cardType; 		// 카드구분 > 01:신용, 11:체크
	
	@BindValue(StartPosition=3, 	Length=100	, Name="CI")
	private String ci;				// CI
	
	@BindValue(StartPosition=103, 	Length=4	, Name="카드번호4자리")
	private String card4No;		// 카드번호뒤네자리
	
	@BindValue(StartPosition=107, 	Length=1	, Name="일시불구분(1:일시불/2:할부)")
	private String allPayType;		// 일시불구분 > 1:일시불, 2:할부
	
	// 일시불 여부
	public boolean IsallPayType() {
		return "1".equals(allPayType);
	}
	
	public String getAllPayTypeCode() {
		// 할부카드유형코드 [WC020]
		if("1".equals(this.allPayType)) {
			return "10"; // 일시불
		}
		else if("2".equals(this.allPayType)) {
			return "20"; // 할부
		}
		else {
			return "30"; // 기타
		}
	}
	
	@BindValue(StartPosition=108, 	Length=10	, Name="승인번호")
	private String agreeNo;		// 승인번호
	
	@BindValue(StartPosition=118, 	Length=11	, Name="매출금액(사용금액)")
	private int useMoney;		// 매출금액
	
	@BindValue(StartPosition=129, 	Length=50	, Name="가맹점명")
	private String storeName;		// 가맹점명
	
	@BindValue(StartPosition=179, 	Length=1	, Name="가족구분(1:본인/2:가족)")
	private String familyType;		// 가족여부 1:본인, 2:가족
	
	@BindValue(StartPosition=180, 	Length=5	, Name="가맹점업종코드")
	private String storeTypeNo;// 가맹점업종코드
	
	@BindValue(StartPosition=185, 	Length=30	, Name="가맹점업종명")
	private String storeTypeName;	// 가맹점업종명
	
	@BindValue(StartPosition=215, 	Length=10	, Name="가맹점사업자번호")
	private String storeBizNo;	// 가맹점사업자번호
	
	@BindValue(StartPosition=225, 	Length=14	, Name="승인일자(사용일자)")
	private String useDate;			// 사용(승인)일자 14자리 YYYYMMDDHHmmss
	
	@BindValue(StartPosition=239, 	Length=5	, Name="상품코드")
	private String designCode;		// 카드상품 코드
	
	@BindValue(StartPosition=244, Length=60, Name="실시간PK")
	private String realTimePK;		// 실시간전문PK (HS13의 매칭 키가 됨)
	
	@BindValue(StartPosition=304, 	Length=1	, Name="분할매입가능여부(0:NO/1:YES)")
	private String enableDivied;	// 분할매입가능여부 0:NO, 1:YES
	
	// 분할매출가능여부
	public boolean EnableDvied() {
		return "1".equals(enableDivied);
	}
	
	/* 하나카드의 경우 아래 업종코드만 분할가능으로 들어옴
	6306	항공사
	6311	대한항공
	6309	아시아나항공
	6303	철도
	6101	호텔(특급)
	5205	농협식품전문점
	6102	호텔(특급외)	
	 */
	
	@BindValue(StartPosition=305, 	Length=20	, Name="가맹점번호")
	private String storeNo;	// 가맹점번호 11자리임	
	
	public MemberInfoModel getMemberInfo() {
		
		return memberInfo;
	}	

	public String getStatementType() {
		return statementType;
	}
	
	public String getStatementTypeCode() {
		
		// 카드매출유형코드 [WC019]
		if("1".equals(this.statementType)) {
			return "10"; // 정상
		}
		else if("2".equals(this.statementType)) {
			return "20"; // 취소
		}
		else {
			return "30"; // 없음
		}
	}

	public void setStatementType(String statementType) {
		this.statementType = statementType;
	}

	public String getCardType() {
		return cardType;
	}

	public void setCardType(String cardType) {
		this.cardType = cardType;
	}

	public String getCi() {
		return ci;
	}

	public void setCi(String ci) {
		this.ci = ci;
	}

	public String getCard4No() {
		return card4No;
	}

	public void setCard4No(String card4No) {
		this.card4No = card4No;
	}

	public String getAllPayType() {
		return allPayType;
	}

	public void setAllPayType(String allPayType) {
		this.allPayType = allPayType;
	}

	public String getAgreeNo() {
		return agreeNo;
	}

	public void setAgreeNo(String agreeNo) {
		this.agreeNo = agreeNo;
	}

	public int getUseMoney() {
		return useMoney;
	}

	public void setUseMoney(int reqMoney) {
		this.useMoney = reqMoney;
	}
	
	public String getUseMoneyString() {
		 return new DecimalFormat("#,###").format(useMoney);
	}

	public String getStoreName() {
		return storeName;
	}

	public void setStoreName(String storeName) {
		this.storeName = storeName;
	}

	public String getFamilyType() {
		return familyType;
	}
	
	public String getFamilyTypeCode() {
		// 가족카드유형코드 [WC021]
		if("1".equals(this.allPayType)) {
			return "10"; // 본인
		}
		else if("2".equals(this.allPayType)) {
			return "20"; // 가족
		}
		else {
			return "30"; // 기타
		}
	}
	
	public boolean isFamilyUse() {
		return "2".equalsIgnoreCase(familyType);
	}

	public void setFamilyType(String familyType) {
		this.familyType = familyType;
	}

	public String getStoreTypeNo() {
		return storeTypeNo;
	}

	public void setStoreTypeNo(String storeTypeNo) {
		this.storeTypeNo = storeTypeNo;
	}

	public String getStoreTypeName() {
		return storeTypeName;
	}

	public void setStoreTypeName(String storeTypeName) {
		this.storeTypeName = storeTypeName;
	}

	public String getStoreBizNo() {
		return storeBizNo;
	}

	public void setStoreBizNo(String storeBizNo) {
		this.storeBizNo = storeBizNo;
	}

	public String getUseDate() {
		return useDate;
	}

	public void setUseDate(String reqDate) {
		this.useDate = reqDate;
	}

	public String getDesignCode() {
		return designCode;
	}

	public void setDesignCode(String designCode) {
		this.designCode = designCode;
	}

	public String getEnableDivied() {
		return enableDivied;
	}

	public void setEnableDivied(String enableDivied) {
		this.enableDivied = enableDivied;
	}

	public String getStoreNo() {
		return storeNo;
	}

	public void setStoreNo(String storeNo) {
		this.storeNo = storeNo;
	}
	
	public Date getUseDateTime() {
		return DateUtil.getDateTime(this.useDate, "yyyyMMddHHmmss");
	}
	public String getUseDateTimeString() {
		return DateUtil.getDateString(getUseDateTime(), "yyyyMMdd");
	}
	
	public String getUseDateTimeString(String format) {
		return DateUtil.getDateString(getUseDateTime(), format);
	}
	
	// 비용처리 SP에서 담을 값
	
	private double applPnt = 0; // 차감금액

	public double getApplPnt() {
		return applPnt;
	}

	public void setApplPnt(double applPnt) {
		this.applPnt = applPnt;
	}
	
	private double remainPnt = 0; // 남은포인트
	

	public double getRemainPnt() {
		return remainPnt;
	}

	public void setRemainPnt(double remainPnt) {
		this.remainPnt = remainPnt;
	}
	
	public String getRemainPntString() {
		return new DecimalFormat("#,###.##").format(remainPnt);
	}
	
	// 차감 후 이전 포인트
	public double getBeforePnt() {
		return remainPnt+applPnt;
	}
	
	public String getBeforePntString() {
		return new DecimalFormat("#,###.##").format(getBeforePnt());
	}

	public String getApplPntString() {
		return new DecimalFormat("#,###.##").format(applPnt);
	}
	
	private String returnCode = "99";
	private String returnMessage = "";

	public String getReturnCode() {
		return returnCode;
	}

	public void setReturnCode(String returnCode) {
		this.returnCode = returnCode;
	}

	public String getReturnMessage() {
		return returnMessage;
	}

	public void setReturnMessage(String returnMessage) {
		this.returnMessage = returnMessage;
	}
}

~~~